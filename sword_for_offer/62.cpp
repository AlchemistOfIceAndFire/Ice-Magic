//
// Created by huanyan on 2021/8/17.
//

/*
 * dp[n][m] 代表 n 个数字每次删除第 m 个数字最后剩余的数字
 *
 * n = 10, m = 3
 * dp[10][3] 对应的数字数组   0 1 2 3 4 5 6 7 8 9
 *
 * dp'[9][3] 对应的数字数组    3 4 5 6 7 8 9 0 1  n - 1 = 9
 * dp[9][3] 对应的数字数组     0 1 2 3 4 5 6 7 8  10 -1 -3 = 6
 *
 * dp[n-1][m]    0   1    ...  n-1-m  n-m  ...  n-3  n-2
 * dp'[n-1][m]   m   m+1  ...  n-1    0    ...  m-3  m-2
 *
 *
 * 对于 dp[n-1][m], n-1位是最后一位数，也是最大的数字，大小为 n-2
 *
 * 对于 dp'[n-1][m], 由于其实dp[n][m]删除一个数字得到，所以其可能的最大数字为 n-1, 由于删除一个数字后，会将 m-1 的数挪到后面，因为下一次查数 m 是从被删除的数字下一位开始.
 * 所以最大数字 n-1 所在的位置为 n - m. 在 dp[n-1][m] 总， n-m 位映射dp'的最大数，由于数组从0开始，所以dp中该位数值为 n - m - 1.
 *
 * 任意对应的两个数字都满足 dp'[n-1][m] = (dp[n-1][m] + m) % n
 *
 *
 * dp'[n-1][m] = (dp[n-1][m] + m) %  n
 *
 * dp[n][m] = (dp[n-1][m] + m) %  n
 *
 * 所以需要从dp[1] 正推到 dp[n]
 *
 * 0 1 2 3 4 5 6 7 8 9 -> 3 4 5 6 7 8 9 0 1 -> 6 7 8 9 0 1 3 4 ->  9 0 1 3 4 6 7 -> 3 4 6 7 9 0 -> 7 9 0 3 4 -> 3 4 7 9 -> 9 3 4 -> 9 3 -> 3
 *
 * dp[1][3] = 0;
 * dp[2][3] = 1;
 * dp[3][3] = 1;
 * dp[4][3] = 0;
 * dp[5][3] = 3;
 * dp[6][3] = 0;
 * dp[7][3] = 3;
 * dp[8][3] = 6;
 * dp[9][3] = 0;
 * dp[10][3] = 3;
 */


class Solution {
public:
    int lastRemaining(int n, int m) {
        int answer = 0;
        for (int i = 2; i <= n; i++) {
            answer = (answer + m) % 2;
        }
        return answer;
    }
};